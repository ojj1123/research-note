# 내의 상태관리 전략 변천사

- redux, 처음에는 flux 패턴, container-presenter 방식
    - 러닝커브 높고, 보일러플레이트가 많아졌다
    - 특정 컴포넌트에서만 사용하면 되는 상태를 전역상태로 관리할 이유가 있나?
    - 특히 비동기 API 상태를 위해 최소 3개의 상태가 필요했다.(데이터, 로딩, 에러) 당시 API가 10개 정도였고 최소 30개의 상태가 필요했던 것이다

- 비동기 상태를 다루기에는 redux는 오버엔지니어링이었고 번잡했다. 단일 스토어를 채택하고 있는 redux의 스토어가 점점 비대해짐을 느꼈다

- 그래서 서버 상태를 다뤄줄 수 있는 swr 과 react query 를 사용하기 시작했다
    - 서버상태는 클라이언트 상태와 다르게 원격 상태이고 주체가 서버이다.
    - 서버상태를 fetch하게 되면 서버의 특정 순간의 스냅샷이기 때문에 stale해질 수 있다.
    - 그러다보니 stale하지 않게 refetch 가 필요하다. 또한 성능을 위해서는 cache 전략도 필요할 것이다.
    - (이외에도 background refetch, 서버 상태에 대한 GC관리, 중복 요청 deduping, 데이터가 언제 out of date 되는지 등을 관리해줘야 한다.)

- 클라이언트 상태의 경우 redux를 사용했었으니 지금은 react 기본 API인 useState, useReducer, context 를 통해 상태를 관리한다
	- 아직은 복잡한 클라이언트 상태를 다뤄본 경험이 없기 때문에 기본 API만으로 모두 해결할 수 있었다.

- 컴포넌트에 의존성 주입을 위해 props drilling이 깊어지면 context 사용

# 복잡한 상태관리?
- context와 같은 react api는 렌더링 최적화에서 한계가 보인다. 특정 context를 구독하는 컴포넌트가 많아지면 context를 변경할 때 구독하고 있는 컴포넌트가 모두 리렌더링된다.
- context로 렌더링 최적화를 해주려면 상태값을 쪼개서 하나의 context 마다 상태를 작게 만들어줘야 하는데, 이렇게 하면 context가 만아지게 되면 provider hell이 생기게 된다
- 그래서 context 는 보통 전역상태도구라고 생각하지 않고 그냥 의존성 주입용 API라고 생각한다. 즉, props drilling을 해결해줄 수 있는 용도 정도로 보통 사용한다.
- [Compound 컴포넌트 패턴](Compound%20컴포넌트%20패턴.md)을 적용할 때 context를 통해 자식 컴포넌트에 상태를 주입해주는 용도로 사용했었다

- 복잡한 상태관리라 하면, 리렌더링 최적화를 도와줄 수거나 메모리 관리 등이 필요할 때를 보통 복잡한 상태라고 생각한다
- 복잡한 상태관리가 필요하면 [상태관리 라이브러리](상태관리%20라이브러리.md)를 도입해보면 좋겠다

# 서버상태 vs 클라이언트 상태
[Tanstack/query - Overview](https://tanstack.com/query/latest/docs/react/overview)

- 서버상태
	- 우리가 컨트롤할 수 없는 원격(remote)에서 유지됨
	- fetching과 updating을 위해 비동기 API를 요구함
	- 다른 사람과 공유될 수 있는 자원이고 우리도 모르게 바귈 수 있음
	- 서버 상태를 신경쓰지 않으면 out of date 해지기 쉬움
- 클라이언트 상태
	- 클라이언트가 통제할 수 있는 상태
	- 보통 동기화되어 있음